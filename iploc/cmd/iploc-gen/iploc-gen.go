package main

import (
	"bytes"
	"compress/zlib"
	"fmt"
	"io"
	"os"
	"strconv"
	"text/template"

	"github.com/kayon/iploc"
	flag "github.com/spf13/pflag"
)

const (
	goFilename = "iploc-binary.go"
	goFileTPL  = `// generated by iploc-gen
package {{ .Package }}

import (
	"github.com/kayon/iploc"
)

var IPLoc *iploc.Locator

func init() {
	var err error
	if IPLoc, err = iploc.{{ .Method }}([]byte({{ .Dat }})); err != nil {
		panic(err)
	}
}`
)

var (
	qqwrySrc string
	pkgName  string
	noIndex  bool
	help     bool
	file     = template.Must(template.New("file").Parse(goFileTPL))
)

func init() {
	flag.StringVarP(&pkgName, "pkg", "p", "main", "package name")
	flag.BoolVarP(&noIndex, "no-index", "n", false, "initialization with OpenWithoutIndexes")
	flag.BoolVarP(&help, "help", "h", false, "this help")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "iploc-gen: convert iploc and DAT into Go source code.\nUsage: iploc-gen [DAT path] [arguments]\nOptions:\n")
		flag.PrintDefaults()
	}
	flag.Parse()
	qqwrySrc = flag.Arg(0)

	if qqwrySrc == "" || help {
		flag.Usage()
		if help {
			os.Exit(0)
		}
		os.Exit(1)
	}
}

type Content struct {
	Dat string
}

func main() {
	p, err := iploc.NewParser(qqwrySrc, true)
	if err != nil {
		fmt.Fprintf(os.Stderr, err.Error())
		os.Exit(1)
	}

	f, err := os.Create(goFilename)
	if err != nil {
		fmt.Fprintf(os.Stderr, err.Error())
		os.Exit(1)
	}
	defer f.Close()

	buffer := bytes.NewBuffer(nil)
	cw, _ := zlib.NewWriterLevel(buffer, zlib.BestCompression)
	_, err = io.Copy(cw, p.Reader())
	cw.Close()

	if err != nil {
		fmt.Fprintf(os.Stderr, err.Error())
		os.Exit(1)
	}

	var method = "Load"
	if noIndex {
		method = "LoadWithoutIndexes"
	}

	file.Execute(f, map[string]string{"Package": pkgName, "Dat": strconv.QuoteToASCII(buffer.String()), "Method": method})
}
